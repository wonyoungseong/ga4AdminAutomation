"""
Enhanced User Service with Registration Workflow and Activity Tracking
"""

from datetime import datetime, timedelta
from typing import List, Optional, Dict, Any
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, and_, or_, desc
from sqlalchemy.orm import selectinload
import secrets
import hashlib
import logging

from ..models.db_models import (
    User, UserRole, UserStatus, RegistrationStatus, Client, ClientAssignment,
    PropertyAccessRequest, UserActivityLog, UserSession, ActivityType,
    PropertyAccessStatus, AccessLevel, ClientAssignmentStatus
)
from ..models.schemas import (
    UserCreate, UserUpdate, UserResponse, UserRegistrationRequest,
    PropertyAccessRequestCreate, UserActivityLogResponse, SystemStatsResponse,
    ClientAssignmentCreate, ClientAssignmentResponse
)
from ..core.exceptions import NotFoundError, ValidationError, AuthorizationError
from .notification_service import NotificationService
from .audit_service import AuditService

logger = logging.getLogger(__name__)


class EnhancedUserService:
    """Enhanced user service with comprehensive registration workflow"""
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self.notification_service = NotificationService(db)
        self.audit_service = AuditService(db)
    
    async def register_user(
        self, 
        registration_data: UserRegistrationRequest,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None
    ) -> UserResponse:
        """
        Register a new user with enhanced workflow
        """
        try:
            # Check if user already exists
            existing_user = await self.db.execute(
                select(User).where(User.email == registration_data.email)
            )
            if existing_user.scalar_one_or_none():
                raise ValidationError("User with this email already exists")
            
            # Generate verification token
            verification_token = secrets.token_urlsafe(32)
            token_expires = datetime.utcnow() + timedelta(hours=24)
            
            # Hash password
            password_hash = self._hash_password(registration_data.password)
            
            # Create user
            user = User(\n                email=registration_data.email,\n                name=registration_data.name,\n                company=registration_data.company,\n                password_hash=password_hash,\n                department=registration_data.department,\n                job_title=registration_data.job_title,\n                phone_number=registration_data.phone_number,\n                primary_client_id=registration_data.requested_client_id,\n                registration_status=RegistrationStatus.PENDING_VERIFICATION,\n                verification_token=verification_token,\n                verification_token_expires_at=token_expires,\n                role=UserRole.REQUESTER,\n                status=UserStatus.INACTIVE\n            )\n            \n            self.db.add(user)\n            await self.db.flush()\n            \n            # Log registration activity\n            await self.log_user_activity(\n                user_id=user.id,\n                activity_type=ActivityType.AUTH,\n                action=\"user_registered\",\n                resource_type=\"user\",\n                resource_id=str(user.id),\n                ip_address=ip_address,\n                user_agent=user_agent,\n                details={\n                    \"email\": user.email,\n                    \"company\": user.company,\n                    \"requested_client_id\": registration_data.requested_client_id,\n                    \"has_business_justification\": bool(registration_data.business_justification)\n                }\n            )\n            \n            # Send verification email\n            await self.notification_service.send_verification_email(\n                user.email,\n                user.name,\n                verification_token\n            )\n            \n            await self.db.commit()\n            return UserResponse.model_validate(user)\n            \n        except Exception as e:\n            await self.db.rollback()\n            logger.error(f\"Error registering user: {e}\")\n            raise\n    \n    async def verify_email(self, token: str) -> bool:\n        \"\"\"Verify user email with token\"\"\"\n        try:\n            user = await self.db.execute(\n                select(User).where(\n                    and_(\n                        User.verification_token == token,\n                        User.verification_token_expires_at > datetime.utcnow(),\n                        User.registration_status == RegistrationStatus.PENDING_VERIFICATION\n                    )\n                )\n            )\n            user = user.scalar_one_or_none()\n            \n            if not user:\n                return False\n            \n            # Verify email\n            success = user.verify_email()\n            if success:\n                await self.log_user_activity(\n                    user_id=user.id,\n                    activity_type=ActivityType.AUTH,\n                    action=\"email_verified\",\n                    resource_type=\"user\",\n                    resource_id=str(user.id)\n                )\n                \n                # Send notification to admins if approval is needed\n                await self.notification_service.notify_admins_new_user(user)\n                \n                await self.db.commit()\n            \n            return success\n            \n        except Exception as e:\n            await self.db.rollback()\n            logger.error(f\"Error verifying email: {e}\")\n            raise\n    \n    async def approve_user(\n        self, \n        user_id: int, \n        approver_id: int, \n        approved: bool,\n        rejection_reason: Optional[str] = None,\n        assigned_role: Optional[UserRole] = None,\n        primary_client_id: Optional[int] = None\n    ) -> UserResponse:\n        \"\"\"Approve or reject a user registration\"\"\"\n        try:\n            user = await self.db.get(User, user_id)\n            if not user:\n                raise NotFoundError(\"User not found\")\n            \n            if approved:\n                success = user.approve_user(approver_id)\n                if success:\n                    if assigned_role:\n                        user.role = assigned_role\n                    if primary_client_id:\n                        user.primary_client_id = primary_client_id\n                    \n                    user.status = UserStatus.ACTIVE\n                    \n                    # Create client assignment if specified\n                    if primary_client_id:\n                        assignment = ClientAssignment(\n                            user_id=user.id,\n                            client_id=primary_client_id,\n                            assigned_by_id=approver_id,\n                            assignment_type=\"manual\",\n                            access_level=AccessLevel.STANDARD,\n                            status=ClientAssignmentStatus.ACTIVE\n                        )\n                        self.db.add(assignment)\n                    \n                    action = \"user_approved\"\n                else:\n                    raise ValidationError(\"Cannot approve user in current state\")\n            else:\n                success = user.reject_user(rejection_reason or \"No reason provided\")\n                action = \"user_rejected\"\n                \n            if success:\n                await self.log_user_activity(\n                    user_id=approver_id,\n                    activity_type=ActivityType.USER_MANAGEMENT,\n                    action=action,\n                    resource_type=\"user\",\n                    resource_id=str(user.id),\n                    target_user_id=user.id,\n                    details={\n                        \"approved\": approved,\n                        \"rejection_reason\": rejection_reason,\n                        \"assigned_role\": assigned_role.value if assigned_role else None,\n                        \"primary_client_id\": primary_client_id\n                    }\n                )\n                \n                # Send notification to user\n                await self.notification_service.send_approval_notification(\n                    user.email,\n                    user.name,\n                    approved,\n                    rejection_reason\n                )\n                \n                await self.db.commit()\n                return UserResponse.model_validate(user)\n            else:\n                raise ValidationError(\"Failed to process user approval\")\n                \n        except Exception as e:\n            await self.db.rollback()\n            logger.error(f\"Error approving user: {e}\")\n            raise\n    \n    async def create_property_access_request(\n        self,\n        user_id: int,\n        request_data: PropertyAccessRequestCreate,\n        ip_address: Optional[str] = None\n    ) -> PropertyAccessRequest:\n        \"\"\"Create a new property access request\"\"\"\n        try:\n            # Verify user has access to the client\n            user_assignment = await self.db.execute(\n                select(ClientAssignment).where(\n                    and_(\n                        ClientAssignment.user_id == user_id,\n                        ClientAssignment.client_id == request_data.client_id,\n                        ClientAssignment.status == ClientAssignmentStatus.ACTIVE\n                    )\n                )\n            )\n            if not user_assignment.scalar_one_or_none():\n                raise AuthorizationError(\"User not assigned to this client\")\n            \n            # Check for existing active request\n            existing = await self.db.execute(\n                select(PropertyAccessRequest).where(\n                    and_(\n                        PropertyAccessRequest.user_id == user_id,\n                        PropertyAccessRequest.requested_property_id == request_data.requested_property_id,\n                        PropertyAccessRequest.target_email == request_data.target_email,\n                        PropertyAccessRequest.status.in_([\n                            PropertyAccessStatus.REQUESTED, \n                            PropertyAccessStatus.APPROVED\n                        ])\n                    )\n                )\n            )\n            if existing.scalar_one_or_none():\n                raise ValidationError(\"Active request already exists for this property and email\")\n            \n            # Create the request\n            request = PropertyAccessRequest(\n                user_id=user_id,\n                client_id=request_data.client_id,\n                requested_property_id=request_data.requested_property_id,\n                target_email=request_data.target_email,\n                permission_level=request_data.permission_level,\n                business_justification=request_data.business_justification,\n                requested_duration_days=request_data.requested_duration_days,\n                priority_level=request_data.priority_level,\n                external_ticket_id=request_data.external_ticket_id,\n                status=PropertyAccessStatus.REQUESTED\n            )\n            \n            # Check for auto-approval\n            auto_approved = await self._check_auto_approval(request)\n            if auto_approved:\n                request.auto_approved = True\n                request.status = PropertyAccessStatus.APPROVED\n                request.approved_at = datetime.utcnow()\n                request.expires_at = datetime.utcnow() + timedelta(days=request.requested_duration_days)\n            \n            self.db.add(request)\n            await self.db.flush()\n            \n            # Log activity\n            await self.log_user_activity(\n                user_id=user_id,\n                activity_type=ActivityType.PERMISSION_MANAGEMENT,\n                action=\"property_access_requested\",\n                resource_type=\"property_access_request\",\n                resource_id=str(request.id),\n                ip_address=ip_address,\n                details={\n                    \"client_id\": request_data.client_id,\n                    \"requested_property_id\": request_data.requested_property_id,\n                    \"permission_level\": request_data.permission_level.value,\n                    \"auto_approved\": auto_approved,\n                    \"priority_level\": request_data.priority_level.value\n                }\n            )\n            \n            # Send notifications\n            if auto_approved:\n                await self.notification_service.send_auto_approval_notification(request)\n            else:\n                await self.notification_service.notify_approvers_new_request(request)\n            \n            await self.db.commit()\n            return request\n            \n        except Exception as e:\n            await self.db.rollback()\n            logger.error(f\"Error creating property access request: {e}\")\n            raise\n    \n    async def log_user_activity(\n        self,\n        user_id: int,\n        activity_type: ActivityType,\n        action: str,\n        resource_type: Optional[str] = None,\n        resource_id: Optional[str] = None,\n        target_user_id: Optional[int] = None,\n        client_id: Optional[int] = None,\n        ip_address: Optional[str] = None,\n        user_agent: Optional[str] = None,\n        session_id: Optional[str] = None,\n        details: Optional[Dict[str, Any]] = None,\n        success: bool = True,\n        error_message: Optional[str] = None,\n        duration_ms: Optional[int] = None\n    ) -> UserActivityLog:\n        \"\"\"Log user activity for audit trail\"\"\"\n        activity_log = UserActivityLog(\n            user_id=user_id,\n            target_user_id=target_user_id,\n            client_id=client_id,\n            activity_type=activity_type,\n            action=action,\n            resource_type=resource_type,\n            resource_id=resource_id,\n            ip_address=ip_address,\n            user_agent=user_agent,\n            session_id=session_id,\n            details=details,\n            success=success,\n            error_message=error_message,\n            duration_ms=duration_ms\n        )\n        \n        self.db.add(activity_log)\n        return activity_log\n    \n    async def create_user_session(\n        self,\n        user_id: int,\n        session_token: str,\n        refresh_token: Optional[str],\n        ip_address: str,\n        user_agent: Optional[str] = None,\n        device_fingerprint: Optional[str] = None,\n        expires_in_hours: int = 24\n    ) -> UserSession:\n        \"\"\"Create a new user session\"\"\"\n        session = UserSession(\n            user_id=user_id,\n            session_token=session_token,\n            refresh_token=refresh_token,\n            ip_address=ip_address,\n            user_agent=user_agent,\n            device_fingerprint=device_fingerprint,\n            expires_at=datetime.utcnow() + timedelta(hours=expires_in_hours)\n        )\n        \n        self.db.add(session)\n        return session\n    \n    async def get_user_activity_logs(\n        self,\n        user_id: Optional[int] = None,\n        activity_type: Optional[ActivityType] = None,\n        action: Optional[str] = None,\n        date_from: Optional[datetime] = None,\n        date_to: Optional[datetime] = None,\n        limit: int = 100,\n        offset: int = 0\n    ) -> List[UserActivityLogResponse]:\n        \"\"\"Get user activity logs with filters\"\"\"\n        query = select(UserActivityLog).options(\n            selectinload(UserActivityLog.user),\n            selectinload(UserActivityLog.target_user),\n            selectinload(UserActivityLog.client)\n        )\n        \n        # Apply filters\n        if user_id:\n            query = query.where(UserActivityLog.user_id == user_id)\n        if activity_type:\n            query = query.where(UserActivityLog.activity_type == activity_type)\n        if action:\n            query = query.where(UserActivityLog.action == action)\n        if date_from:\n            query = query.where(UserActivityLog.created_at >= date_from)\n        if date_to:\n            query = query.where(UserActivityLog.created_at <= date_to)\n        \n        query = query.order_by(desc(UserActivityLog.created_at))\n        query = query.offset(offset).limit(limit)\n        \n        result = await self.db.execute(query)\n        logs = result.scalars().all()\n        \n        return [UserActivityLogResponse.model_validate(log) for log in logs]\n    \n    async def get_system_stats(self) -> SystemStatsResponse:\n        \"\"\"Get comprehensive system statistics\"\"\"\n        # User statistics\n        user_stats = await self.db.execute(\n            select(\n                func.count(User.id).label('total'),\n                func.sum(func.case((User.status == UserStatus.ACTIVE, 1), else_=0)).label('active'),\n                func.sum(func.case((User.registration_status == RegistrationStatus.PENDING_VERIFICATION, 1), else_=0)).label('pending_verification'),\n                func.sum(func.case((User.registration_status == RegistrationStatus.VERIFIED, 1), else_=0)).label('pending_approval'),\n                func.sum(func.case((User.registration_status == RegistrationStatus.APPROVED, 1), else_=0)).label('approved'),\n                func.sum(func.case((User.registration_status == RegistrationStatus.REJECTED, 1), else_=0)).label('rejected'),\n                func.sum(func.case((User.status == UserStatus.SUSPENDED, 1), else_=0)).label('suspended')\n            )\n        )\n        user_row = user_stats.first()\n        \n        # Property request statistics\n        request_stats = await self.db.execute(\n            select(\n                func.count(PropertyAccessRequest.id).label('total'),\n                func.sum(func.case((PropertyAccessRequest.status == PropertyAccessStatus.REQUESTED, 1), else_=0)).label('requested'),\n                func.sum(func.case((PropertyAccessRequest.status == PropertyAccessStatus.APPROVED, 1), else_=0)).label('approved'),\n                func.sum(func.case((PropertyAccessRequest.status == PropertyAccessStatus.DENIED, 1), else_=0)).label('denied'),\n                func.sum(func.case((PropertyAccessRequest.status == PropertyAccessStatus.REVOKED, 1), else_=0)).label('revoked'),\n                func.sum(func.case((PropertyAccessRequest.status == PropertyAccessStatus.EXPIRED, 1), else_=0)).label('expired')\n            )\n        )\n        request_row = request_stats.first()\n        \n        # Client assignment statistics\n        assignment_stats = await self.db.execute(\n            select(\n                func.count(ClientAssignment.id).label('total'),\n                func.sum(func.case((ClientAssignment.status == ClientAssignmentStatus.ACTIVE, 1), else_=0)).label('active'),\n                func.sum(func.case((ClientAssignment.status == ClientAssignmentStatus.INACTIVE, 1), else_=0)).label('inactive'),\n                func.sum(func.case((ClientAssignment.status == ClientAssignmentStatus.SUSPENDED, 1), else_=0)).label('suspended')\n            )\n        )\n        assignment_row = assignment_stats.first()\n        \n        # Activity statistics\n        today = datetime.utcnow().date()\n        activity_stats = await self.db.execute(\n            select(\n                func.count(UserActivityLog.id).label('total_activities'),\n                func.sum(func.case((UserActivityLog.success == True, 1), else_=0)).label('successful_activities'),\n                func.sum(func.case((UserActivityLog.success == False, 1), else_=0)).label('failed_activities'),\n                func.count(func.distinct(UserActivityLog.user_id)).filter(\n                    func.date(UserActivityLog.created_at) == today\n                ).label('unique_users_today'),\n                func.count(func.distinct(UserActivityLog.ip_address)).filter(\n                    func.date(UserActivityLog.created_at) == today\n                ).label('unique_ips_today')\n            )\n        )\n        activity_row = activity_stats.first()\n        \n        return SystemStatsResponse(\n            users={\n                \"total\": user_row.total or 0,\n                \"active\": user_row.active or 0,\n                \"pending_verification\": user_row.pending_verification or 0,\n                \"pending_approval\": user_row.pending_approval or 0,\n                \"approved\": user_row.approved or 0,\n                \"rejected\": user_row.rejected or 0,\n                \"suspended\": user_row.suspended or 0\n            },\n            property_requests={\n                \"total\": request_row.total or 0,\n                \"requested\": request_row.requested or 0,\n                \"approved\": request_row.approved or 0,\n                \"denied\": request_row.denied or 0,\n                \"revoked\": request_row.revoked or 0,\n                \"expired\": request_row.expired or 0\n            },\n            client_assignments={\n                \"total\": assignment_row.total or 0,\n                \"active\": assignment_row.active or 0,\n                \"inactive\": assignment_row.inactive or 0,\n                \"suspended\": assignment_row.suspended or 0\n            },\n            activity_summary={\n                \"total_activities\": activity_row.total_activities or 0,\n                \"successful_activities\": activity_row.successful_activities or 0,\n                \"failed_activities\": activity_row.failed_activities or 0,\n                \"unique_users_today\": activity_row.unique_users_today or 0,\n                \"unique_ips_today\": activity_row.unique_ips_today or 0\n            },\n            generated_at=datetime.utcnow()\n        )\n    \n    async def _check_auto_approval(self, request: PropertyAccessRequest) -> bool:\n        \"\"\"Check if request qualifies for auto-approval\"\"\"\n        # Basic auto-approval logic - can be enhanced based on business rules\n        # For now, only viewer permissions for standard users can be auto-approved\n        if request.permission_level in [\"viewer\", \"analyst\"]:\n            # Check if property allows auto-approval\n            # This would typically check GA4Property.auto_approval_enabled\n            return True\n        return False\n    \n    def _hash_password(self, password: str) -> str:\n        \"\"\"Hash password using SHA-256 (in production, use bcrypt or similar)\"\"\"\n        return hashlib.sha256(password.encode()).hexdigest()\n    \n    async def cleanup_expired_sessions(self) -> int:\n        \"\"\"Clean up expired sessions\"\"\"\n        result = await self.db.execute(\n            select(UserSession).where(\n                and_(\n                    UserSession.is_active == True,\n                    UserSession.expires_at < datetime.utcnow()\n                )\n            )\n        )\n        expired_sessions = result.scalars().all()\n        \n        count = 0\n        for session in expired_sessions:\n            session.terminate_session(\"timeout\")\n            count += 1\n        \n        await self.db.commit()\n        return count