"""
Enhanced Users API routes with Registration Workflow and Activity Tracking
"""

from fastapi import APIRouter, Depends, HTTPException, status, Query, Request
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Annotated, Optional, List
from datetime import datetime

from ...core.database import get_db
from ...core.exceptions import NotFoundError, AuthorizationError, ValidationError, SecurityError
from ...models.schemas import (
    UserResponse, UserUpdate, UserRegistrationRequest, EmailVerificationRequest,
    UserApprovalRequest, PaginatedResponse, UserActivityLogResponse, SystemStatsResponse,
    PropertyAccessRequestCreate, PropertyAccessRequestResponse, AuditSearchRequest
)
from ...models.db_models import UserRole, UserStatus, RegistrationStatus, ActivityType
from ...services.enhanced_auth_service import EnhancedAuthService
from ...services.enhanced_user_service import EnhancedUserService

router = APIRouter()


def get_client_ip(request: Request) -> str:
    """Extract client IP address from request"""
    # Check for forwarded headers first (for reverse proxy setups)
    forwarded_for = request.headers.get("X-Forwarded-For")\n    if forwarded_for:\n        return forwarded_for.split(\",\")[0].strip()\n    \n    real_ip = request.headers.get(\"X-Real-IP\")\n    if real_ip:\n        return real_ip\n    \n    # Fallback to direct client IP\n    return request.client.host if request.client else \"unknown\"\n\n\ndef get_user_agent(request: Request) -> str:\n    \"\"\"Extract user agent from request\"\"\"\n    return request.headers.get(\"User-Agent\", \"unknown\")\n\n\n@router.post(\"/register\", response_model=UserResponse)\nasync def register_user(\n    registration_data: UserRegistrationRequest,\n    request: Request,\n    db: Annotated[AsyncSession, Depends(get_db)]\n):\n    \"\"\"Register a new user with enhanced workflow\"\"\"\n    try:\n        user_service = EnhancedUserService(db)\n        ip_address = get_client_ip(request)\n        user_agent = get_user_agent(request)\n        \n        user = await user_service.register_user(\n            registration_data,\n            ip_address=ip_address,\n            user_agent=user_agent\n        )\n        return user\n    except ValidationError as e:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=e.message\n        )\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Registration failed: {str(e)}\"\n        )\n\n\n@router.post(\"/verify-email\")\nasync def verify_email(\n    verification_data: EmailVerificationRequest,\n    db: Annotated[AsyncSession, Depends(get_db)]\n):\n    \"\"\"Verify user email with token\"\"\"\n    try:\n        user_service = EnhancedUserService(db)\n        success = await user_service.verify_email(verification_data.token)\n        \n        if success:\n            return {\"message\": \"Email verified successfully. Your account is now pending approval.\"}\n        else:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Invalid or expired verification token\"\n            )\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Email verification failed: {str(e)}\"\n        )\n\n\n@router.get(\"/\", response_model=List[UserResponse])\nasync def list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(100, ge=1, le=1000),\n    role: Optional[UserRole] = None,\n    status: Optional[UserStatus] = None,\n    registration_status: Optional[RegistrationStatus] = None,\n    current_user: Annotated[dict, Depends(EnhancedAuthService.get_current_user)] = None,\n    db: Annotated[AsyncSession, Depends(get_db)] = None\n):\n    \"\"\"List users with enhanced filters\"\"\"\n    try:\n        # Only admin and super_admin can list users\n        if not current_user:\n            raise HTTPException(\n                status_code=status.HTTP_401_UNAUTHORIZED,\n                detail=\"Not authenticated\"\n            )\n        \n        user_role = current_user.get(\"role\")\n        if user_role not in [\"admin\", \"super_admin\", \"Admin\", \"Super Admin\"]:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=f\"Insufficient permissions to list users. Role: {user_role}\"\n            )\n        \n        user_service = EnhancedUserService(db)\n        users = await user_service.list_users(\n            skip=skip,\n            limit=limit,\n            role=role,\n            status=status,\n            registration_status=registration_status\n        )\n        return users\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Internal error: {str(e)}\"\n        )\n\n\n@router.get(\"/pending-approval\", response_model=List[UserResponse])\nasync def list_pending_approval_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(50, ge=1, le=200),\n    current_user: Annotated[dict, Depends(EnhancedAuthService.get_current_user)] = None,\n    db: Annotated[AsyncSession, Depends(get_db)] = None\n):\n    \"\"\"List users pending approval\"\"\"\n    try:\n        # Only admin and super_admin can view pending approvals\n        user_role = current_user.get(\"role\")\n        if user_role not in [\"admin\", \"super_admin\", \"Admin\", \"Super Admin\"]:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Insufficient permissions\"\n            )\n        \n        user_service = EnhancedUserService(db)\n        users = await user_service.list_users(\n            skip=skip,\n            limit=limit,\n            registration_status=RegistrationStatus.VERIFIED\n        )\n        return users\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Internal error: {str(e)}\"\n        )\n\n\n@router.post(\"/{user_id}/approve\", response_model=UserResponse)\nasync def approve_user(\n    user_id: int,\n    approval_data: UserApprovalRequest,\n    current_user: Annotated[dict, Depends(EnhancedAuthService.get_current_user)] = None,\n    db: Annotated[AsyncSession, Depends(get_db)] = None\n):\n    \"\"\"Approve or reject a user registration\"\"\"\n    try:\n        # Only admin and super_admin can approve users\n        user_role = current_user.get(\"role\")\n        if user_role not in [\"admin\", \"super_admin\", \"Admin\", \"Super Admin\"]:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Insufficient permissions to approve users\"\n            )\n        \n        approver_id = current_user.get(\"user_id\")\n        user_service = EnhancedUserService(db)\n        \n        user = await user_service.approve_user(\n            user_id=user_id,\n            approver_id=approver_id,\n            approved=approval_data.approved,\n            rejection_reason=approval_data.rejection_reason,\n            assigned_role=approval_data.assigned_role,\n            primary_client_id=approval_data.primary_client_id\n        )\n        return user\n        \n    except NotFoundError as e:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=e.message\n        )\n    except ValidationError as e:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=e.message\n        )\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Approval failed: {str(e)}\"\n        )\n\n\n@router.post(\"/property-access-request\", response_model=PropertyAccessRequestResponse)\nasync def create_property_access_request(\n    request_data: PropertyAccessRequestCreate,\n    request: Request,\n    current_user: Annotated[dict, Depends(EnhancedAuthService.get_current_user)] = None,\n    db: Annotated[AsyncSession, Depends(get_db)] = None\n):\n    \"\"\"Create a new property access request\"\"\"\n    try:\n        user_id = current_user.get(\"user_id\")\n        ip_address = get_client_ip(request)\n        \n        user_service = EnhancedUserService(db)\n        access_request = await user_service.create_property_access_request(\n            user_id=user_id,\n            request_data=request_data,\n            ip_address=ip_address\n        )\n        \n        return PropertyAccessRequestResponse.model_validate(access_request)\n        \n    except AuthorizationError as e:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=e.message\n        )\n    except ValidationError as e:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=e.message\n        )\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Request creation failed: {str(e)}\"\n        )\n\n\n@router.get(\"/activity-logs\", response_model=List[UserActivityLogResponse])\nasync def get_user_activity_logs(\n    user_id: Optional[int] = Query(None, description=\"Filter by specific user ID\"),\n    activity_type: Optional[ActivityType] = Query(None, description=\"Filter by activity type\"),\n    action: Optional[str] = Query(None, description=\"Filter by specific action\"),\n    date_from: Optional[datetime] = Query(None, description=\"Filter from date\"),\n    date_to: Optional[datetime] = Query(None, description=\"Filter to date\"),\n    limit: int = Query(100, ge=1, le=1000, description=\"Maximum number of records\"),\n    offset: int = Query(0, ge=0, description=\"Number of records to skip\"),\n    current_user: Annotated[dict, Depends(EnhancedAuthService.get_current_user)] = None,\n    db: Annotated[AsyncSession, Depends(get_db)] = None\n):\n    \"\"\"Get user activity logs with filters\"\"\"\n    try:\n        # Permission check\n        user_role = current_user.get(\"role\")\n        current_user_id = current_user.get(\"user_id\")\n        \n        # Admins can see all logs, users can only see their own\n        if user_role not in [\"admin\", \"super_admin\", \"Admin\", \"Super Admin\"]:\n            if user_id and user_id != current_user_id:\n                raise HTTPException(\n                    status_code=status.HTTP_403_FORBIDDEN,\n                    detail=\"Cannot view other users' activity logs\"\n                )\n            user_id = current_user_id  # Force to current user\n        \n        user_service = EnhancedUserService(db)\n        logs = await user_service.get_user_activity_logs(\n            user_id=user_id,\n            activity_type=activity_type,\n            action=action,\n            date_from=date_from,\n            date_to=date_to,\n            limit=limit,\n            offset=offset\n        )\n        return logs\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Failed to retrieve activity logs: {str(e)}\"\n        )\n\n\n@router.get(\"/system-stats\", response_model=SystemStatsResponse)\nasync def get_system_statistics(\n    current_user: Annotated[dict, Depends(EnhancedAuthService.get_current_user)] = None,\n    db: Annotated[AsyncSession, Depends(get_db)] = None\n):\n    \"\"\"Get comprehensive system statistics\"\"\"\n    try:\n        # Only admin and super_admin can view system stats\n        user_role = current_user.get(\"role\")\n        if user_role not in [\"admin\", \"super_admin\", \"Admin\", \"Super Admin\"]:\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Insufficient permissions to view system statistics\"\n            )\n        \n        user_service = EnhancedUserService(db)\n        stats = await user_service.get_system_stats()\n        return stats\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Failed to retrieve system statistics: {str(e)}\"\n        )\n\n\n@router.get(\"/{user_id}\", response_model=UserResponse)\nasync def get_user(\n    user_id: int,\n    current_user: Annotated[dict, Depends(EnhancedAuthService.get_current_user)] = None,\n    db: Annotated[AsyncSession, Depends(get_db)] = None\n):\n    \"\"\"Get user by ID with enhanced details\"\"\"\n    # Users can only view their own profile or admins can view any\n    current_user_role = current_user.get(\"role\")\n    current_user_id = current_user.get(\"user_id\")\n    \n    if (current_user_role not in [\"admin\", \"super_admin\", \"Admin\", \"Super Admin\"] and \n        current_user_id != user_id):\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Insufficient permissions to view this user\"\n        )\n    \n    user_service = EnhancedUserService(db)\n    user = await user_service.get_user_by_id(user_id)\n    \n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=\"User not found\"\n        )\n    \n    return user\n\n\n@router.put(\"/{user_id}\", response_model=UserResponse)\nasync def update_user(\n    user_id: int,\n    user_data: UserUpdate,\n    current_user: Annotated[dict, Depends(EnhancedAuthService.get_current_user)] = None,\n    db: Annotated[AsyncSession, Depends(get_db)] = None\n):\n    \"\"\"Update user with enhanced validation\"\"\"\n    # Check permissions - only admins or the user themselves can update\n    current_role = current_user.get(\"role\")\n    current_user_id = current_user.get(\"user_id\")\n    \n    if current_role not in [\"super_admin\", \"admin\", \"Super Admin\", \"Admin\"] and current_user_id != user_id:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Insufficient permissions\"\n        )\n    \n    # Restrict certain fields for non-admin users\n    if current_role not in [\"super_admin\", \"admin\", \"Super Admin\", \"Admin\"]:\n        if any([user_data.role, user_data.status, user_data.registration_status]):\n            raise HTTPException(\n                status_code=status.HTTP_403_FORBIDDEN,\n                detail=\"Cannot modify role, status, or registration status\"\n            )\n    \n    try:\n        user_service = EnhancedUserService(db)\n        user = await user_service.update_user(user_id, user_data)\n        return user\n    except NotFoundError as e:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=e.message\n        )\n    except ValidationError as e:\n        raise HTTPException(\n            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\n            detail=e.message\n        )\n\n\n@router.delete(\"/{user_id}\")\nasync def delete_user(\n    user_id: int,\n    current_user: Annotated[dict, Depends(EnhancedAuthService.get_current_user)] = None,\n    db: Annotated[AsyncSession, Depends(get_db)] = None\n):\n    \"\"\"Delete user (super admin only)\"\"\"\n    # Only super admins can delete users\n    if current_user.get(\"role\") not in [\"super_admin\", \"Super Admin\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Insufficient permissions\"\n        )\n    \n    try:\n        user_service = EnhancedUserService(db)\n        await user_service.delete_user(user_id)\n        return {\"message\": \"User deleted successfully\"}\n    except NotFoundError as e:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=e.message\n        )\n\n\n@router.post(\"/cleanup-sessions\")\nasync def cleanup_expired_sessions(\n    current_user: Annotated[dict, Depends(EnhancedAuthService.get_current_user)] = None,\n    db: Annotated[AsyncSession, Depends(get_db)] = None\n):\n    \"\"\"Cleanup expired sessions (admin only)\"\"\"\n    # Only admins can trigger session cleanup\n    if current_user.get(\"role\") not in [\"admin\", \"super_admin\", \"Admin\", \"Super Admin\"]:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Insufficient permissions\"\n        )\n    \n    try:\n        user_service = EnhancedUserService(db)\n        cleaned_count = await user_service.cleanup_expired_sessions()\n        return {\n            \"message\": f\"Cleaned up {cleaned_count} expired sessions\",\n            \"cleaned_sessions\": cleaned_count\n        }\n    except Exception as e:\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Session cleanup failed: {str(e)}\"\n        )